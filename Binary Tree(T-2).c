#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>
#include "t1.h"
#include "t2.h"

bool is_prop(char p) //Checks if a character is a propositonal atom. Considers only 26 propositional atoms. The limit
                    // of propositional atoms of this program is the set of small case alphabets a-z.
{
	if (p >=97 && p <= 122)
	{
		return true;
	}
	else
    return false;
}

//int end_tree = 0; // Stores the value of the probable index of the corresponding right sub_tree in the prefix array.

/* This function takes the prefix expression generated by the infix to prefix function and makes a rooted binary parse tree
out of it. The implementation of the function uses pointers and recursion.The argument that goes into the function is the
index of the character in the prefix(from where the tree/sub_tree has to start).Returns a pointer of type Node.*/

Node* create_node(int start)
{
    end_tree   = end_tree + 1;

	Node* temp = (Node*)malloc(sizeof(Node)); // Creating a node and making a pointer of type Node point to it.

	temp->left = temp->right = NULL;

	temp->data = prefix[start]; // Give the node the value at the index in prefix array.

	if (prefix[start] == '*'|| prefix[start] == '>' || prefix[start] == '+')
	{
		temp->left  = create_node(start+1);
		temp->right = create_node(end_tree); //Because end_tree remembers the index that right_node has to take
	}                                        // and is incremented at every node creation.

	else if (prefix[start]=='~')
	{
		temp->left  = NULL;                 // When ~ is encountered,left is assigned to null to make tree compatible for
		temp->right = create_node(start+1); // In-order traversal.
	}

	else if(is_prop(prefix[start]))          // If the data of the node is a proposition, point both left and right sub_tree
    {                                       //pointers to NULL.
        temp->left  = NULL;
        temp->right = NULL;
    }
	return temp;
}

